---
title: "Challenge Groups"
subtitle: "Run ID: `r params$run_id`"
date: "`r Sys.Date()`"
author: "Cook County Assessor's Office Data Department"
abstract-title: "Run Note"
abstract: '`r arrow::read_parquet(here::here("output/metadata/model_metadata.parquet"))$run_note`'
execute:
  echo: false
  warning: false
format:
  html:
    embed-resources: true
    toc: true
    toc_float: true
    fig-align: center
    fontsize: 12pt
knitr:
  opts_chunk:
    out.width: "100%"
editor: source
params:
  run_id: "2024-01-07-great-ida"
  year: "2024"
---

{{< include ../_setup.qmd >}}

## Topline Stats

```{r _challenge_groups_topline_stats}
large_lots <- assessment_pin %>%
  filter(flag_land_gte_95_percentile == TRUE) %>%
  select(meta_pin, pred_pin_initial_fmv, sale_recent_1_price, loc_latitude, loc_longitude, prior_near_tot) %>%
  filter(!is.na(sale_recent_1_price))

multicard <- assessment_pin %>%
  filter(flag_pin_is_multicard == TRUE) %>%
  select(meta_pin, pred_pin_initial_fmv, sale_recent_1_price, loc_latitude, loc_longitude, prior_near_tot) %>%
  filter(!is.na(sale_recent_1_price))

multifamily <- assessment_pin %>%
  filter(meta_class == "211") %>%
  select(meta_pin, pred_pin_initial_fmv, sale_recent_1_price, loc_latitude, loc_longitude, prior_near_tot) %>%
  filter(!is.na(sale_recent_1_price))

top_decile <- assessment_pin %>%
  filter(flag_prior_near_fmv_top_decile  == TRUE) %>%
  select(meta_pin, pred_pin_initial_fmv, sale_recent_1_price, loc_latitude, loc_longitude, prior_near_tot) %>%
  filter(!is.na(sale_recent_1_price))

critical_values_missing <- assessment_pin %>%
  filter(flag_char_missing_critical_value  == TRUE) %>%
  select(meta_pin, pred_pin_initial_fmv, sale_recent_1_price, loc_latitude, loc_longitude, prior_near_tot) %>%
  filter(!is.na(sale_recent_1_price))


  gte_n <- \(n_sales, min_n, fn, na_type) {
    ifelse(sum(!is.na(n_sales)) >= min_n, fn, na_type)
  }

min_n <- 10


rs_fns_list <- list(
    cod_no_sop = \(x, y) gte_n(y, 2, cod(x / y, na.rm = TRUE), NA_real_),
    prd_no_sop = \(x, y) gte_n(y, 2, prd(x, y, na.rm = TRUE), NA_real_),
    prb_no_sop = \(x, y) gte_n(y, 2, prb(x, y, na.rm = TRUE), NA_real_),
    mki_no_sop = \(x, y) gte_n(y, 2, mki(x, y, na.rm = TRUE), NA_real_),
    cod = \(x, y) gte_n(y, min_n, cod(x / y, na.rm = TRUE), NA_real_),
    cod_met = \(x, y) gte_n(y, min_n, cod_met(cod(x / y, na.rm = TRUE)), NA),
    prd = \(x, y) gte_n(y, min_n, prd(x, y, na.rm = TRUE), NA_real_),
    prd_met = \(x, y) gte_n(y, min_n, prd_met(prd(x, y, na.rm = TRUE)), NA),
    prb = \(x, y) gte_n(y, min_n, prb(x, y, na.rm = TRUE), NA_real_),
    prb_met = \(x, y) gte_n(y, min_n, prb_met(prb(x, y, na.rm = TRUE)), NA),
    mki = \(x, y) gte_n(y, min_n, mki(x, y, na.rm = TRUE), NA_real_),
    mki_met = \(x, y) gte_n(y, min_n, mki_met(mki(x, y, na.rm = TRUE)), NA),
    min = \(x) min(x, na.rm = TRUE),
    q25 = \(x) quantile(x, na.rm = TRUE, probs = 0.25),
    median = \(x) median(x, na.rm = TRUE),
    q75 = \(x) quantile(x, na.rm = TRUE, probs = 0.75),
    max = \(x) max(x, na.rm = TRUE)
  )
  
  ys_fns_list <- list(
    rmse        = rmse_vec,
    r_squared   = rsq_vec,
    mae         = mae_vec,
    mpe         = mpe_vec,
    mape        = mape_vec,
    mdape       = mdape_vec # From R/helpers.R
  )

apply_functions <- function(dataset, dataset_name) {
  count <- nrow(dataset)
  median_prior_near_tot <- median(dataset$prior_near_tot, na.rm = TRUE)

  x <- dataset$pred_pin_initial_fmv
  y <- dataset$sale_recent_1_price
  
  results_rs <- lapply(rs_fns_list, function(f) {
    if (length(formals(f)) == 2) {
      f(x, y)
    } else {
      f(x)
    }
  })
  
  results_df <- as.data.frame(results_rs)
  results_df$dataset <- dataset_name
  results_df$count <- count
  results_df$median_prior_near_tot <- median_prior_near_tot
  results_df$median_estimate <- median_estimate
  
  return(results_df)
}

# Apply the function to each dataset and combine the results
results1 <- bind_rows(
  apply_functions(large_lots, "large_lots"),
  apply_functions(multicard, "multicard"),
  apply_functions(multifamily, "multifamily"),
  apply_functions(top_decile, "top_decile"),
  apply_functions(critical_values_missing, "critical_values_missing")
)


apply_functions <- function(dataset) {
  truth <- dataset$pred_pin_initial_fmv
  estimate <- dataset$sale_recent_1_price
  
  results_ys <- map(ys_fns_list, function(f) f(truth, estimate))

  results_df <- as.data.frame(results_ys)
  
  results_df$dataset_2 <- deparse(substitute(dataset))
  
  return(results_df)
}

results2 <- bind_rows(
  apply_functions(large_lots),
  apply_functions(multicard),
  apply_functions(multifamily),
  apply_functions(top_decile),
  apply_functions(critical_values_missing)
)


table <- cbind(results1, results2) %>%
  as.data.frame() %>%
  mutate(median_ratio = median / median_prior_near_tot) %>%
  select(dataset, median_ratio, cod, prb, prd, mki, min, q25, median, q75, max, rmse, r_squared, mae, mpe, mape, mdape, median_prior_near_tot) %>%
  kable(format = "html", digits = 2, row.names = FALSE) %>%  
  kable_styling()

table
```


```{r _challenge_groups_plot_function}

datasets <- list(
  "Large Lots" = large_lots,
  "Multicard" = multicard,
  "Multifamily" = multifamily,
  "Top Decile" = top_decile,
  "Critical Values Missing" = critical_values_missing
)
plots <- imap(datasets, ~ {
  ggplot(.x, aes(x = sale_recent_1_price, y = pred_pin_initial_fmv)) + 
    geom_point() +
    geom_abline(intercept = 0, slope = 1, color = "red") +  
    xlim(0, 3000000) +  
    ylim(0, 3000000) +  
    theme_bw(base_size = 18) +
    xlab("Sale Price") + 
    ylab("Predicted Price")   
})


```
## Relationship Between Sale and Assessed Values
::: {.panel-tabset}

```{r _challenge_groups_plot_output, results = 'asis'}

iwalk(plots, ~ {
  cat('## ', .y, '\n\n')  
  
  print(.x)
  
  cat('\n\n')
  
})

```
:::

```{r _challenge_groups_map_function}
process_and_plot <- function(data) {
  # Load town shape data
  town_shp <- ccao::town_shp

  # Convert your data to spatial data
  spatial_data <- st_as_sf(data, coords = c("loc_longitude", "loc_latitude"), crs = 4326) %>%
    mutate(Increase = pmin(100 * (pred_pin_initial_fmv / prior_near_tot), 300))

  # Ensure town_shp is in the same CRS
  town_shp <- st_transform(town_shp, crs = st_crs(spatial_data))

  # Create the plot
  ggplot() +
    geom_sf(data = spatial_data, aes(color = Increase)) +  # Plot your data
    geom_sf(data = town_shp, fill = NA, color = "black") +  # Plot town boundaries
    theme_minimal() +
    labs(color = "Increase (%)") +
    theme(axis.title.x = element_blank(),    
          axis.title.y = element_blank(),   
          axis.text.x = element_blank(),    
          axis.text.y = element_blank())    
}
plots <- lapply(datasets, process_and_plot)
```

## Map of YoY Assessed Price Changes
Values are capped at an increase of 300% to increase legibility.

::: {.panel-tabset}

```{r _challenge_groups_map_output, results = 'asis'}

iwalk(plots, ~ {
  cat('## ', .y, '\n\n')
  
  print(.x)
  
  cat('\n\n')
  
})

```
:::

