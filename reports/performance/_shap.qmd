{{< include ../_setup.qmd >}}

# SHAP Values

SHAP values are a way to explain the importance of specific features within the model.
They represent both the direction and magnitude of a feature's impact on an individual
property's predicted value. Summed together, the SHAP values of all features for a given
property should equal the difference between the predicted value and the baseline value.

## Overall Feature Importance

Aggregate feature importance scores ***for the target triad***. The length of the bars corresponds to the `Mean Abs.` column in the table below.

```{r _shap_filtering, warning=FALSE}
shap_predictors <- unlist(metadata$model_predictor_all_name)

shap_df_filtered <- shap_df %>%
  mutate(meta_triad = ccao::town_get_triad(as.character(township_code))) %>%
  filter(meta_triad == run_triad_code) %>%
  arrange(meta_pin, meta_card_num)

shap_df_filtered_long <- shap_df_filtered %>%
  select(township_code, all_of(shap_predictors)) %>%
  pivot_longer(
    cols = all_of(shap_predictors),
    names_to = "feature",
    values_to = "shap"
  )
```

```{r _shap_function}
assessment_card_filtered <- assessment_card %>%
  mutate(meta_triad = ccao::town_get_triad(as.character(township_code))) %>%
  filter(meta_triad == run_triad_code) %>%
  arrange(meta_pin, meta_card_num)

create_shapviz <- function(shap_df, assessment_df, idx) {
  shapviz::shapviz(
    object = shap_df_filtered %>%
      select(all_of(shap_predictors)) %>%
      slice(idx) %>%
      as.matrix(),
    X = assessment_df %>%
      select(all_of(shap_predictors)) %>%
      slice(idx),
    baseline = shap_df_filtered$pred_card_shap_baseline_fmv[1]
  )
}
```

```{r _shap_triad_plot, warning=FALSE}
shap_townships_list <- shap_df_filtered %>%
  distinct(township_code) %>%
  pull() %>%
  as.character()

shap_idx_full_model <- which(
  as.character(assessment_card_filtered$township_code) %in% shap_townships_list
)

shapviz::shapviz(
  object = shap_df_filtered %>%
    select(all_of(shap_predictors)) %>%
    slice(shap_idx_full_model) %>%
    as.matrix(),
  X = assessment_card_filtered %>%
    select(all_of(shap_predictors)) %>%
    slice(shap_idx_full_model),
  baseline = shap_df_filtered$pred_card_shap_baseline_fmv[1]
) %>%
  shapviz::sv_importance(
    kind = "bar",
    max_display = 25L
  ) +
  labs(x = "Mean Abs. SHAP Value") +
  scale_x_continuous(
    labels = scales::dollar,
    expand = expansion(mult = c(0, 0.1))
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_text(margin = margin(t = 10))
  )
```

```{r _shap_triad_table}
shap_df_filtered_long %>%
  group_by(feature) %>%
  summarize(
    `Mean Abs.` = mean(abs(shap)),
    `Median Abs.` = median(abs(shap)),
    Mean = mean(shap),
    Median = median(shap),
    SD = sd(shap),
    `Min.` = min(shap),
    `Max.` = max(shap)
  ) %>%
  mutate(`Rel. Imp.` = `Mean Abs.` / sum(`Mean Abs.`)) %>%
  relocate(`Rel. Imp.`, .after = feature) %>%
  arrange(desc(`Mean Abs.`)) %>%
  mutate(
    across(`Mean Abs.`:`Max.`, ~ scales::dollar(.x, accuracy = 0.01)),
    `Rel. Imp.` = scales::percent(`Rel. Imp.`, accuracy = 0.01)
  ) %>%
  rename(Feature = feature) %>%
  datatable(
    rownames = FALSE,
    options = list(
      columnDefs = list(
        list(
          className = "dt-nowrap dt-right",
          targets = c(1:8)
        )
      )
    )
  )
```

## Feature Importance by Township

::: {.panel-tabset}

```{r _shap_township_plot, results='asis', warning=FALSE}
# Dynamically produce tabset
for (township in shap_townships_list) {
  cat("##", ccao::town_convert(township), "\n")
  shap_idx <- which(
    as.character(assessment_card_filtered$township_code) == township
  )
  print(
    create_shapviz(
      shap_df_filtered,
      assessment_card_filtered,
      shap_idx
    ) %>%
      shapviz::sv_importance(
        kind = "bar",
        max_display = 25L
      ) +
      labs(x = "Mean Abs. SHAP Value") +
      scale_x_continuous(
        labels = scales::dollar,
        expand = expansion(mult = c(0, 0.1))
      ) +
      theme_minimal() +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.x = element_text(margin = margin(t = 10))
      )
  )
  cat("\n\n")
}
```

:::

```{r _shap_township_table}
shap_df_filtered_long %>%
  group_by(feature, township_code) %>%
  summarize(
    `Mean Abs.` = mean(abs(shap)),
    `Median Abs.` = median(abs(shap)),
    Mean = mean(shap),
    Median = median(shap),
    SD = sd(shap),
    `Min.` = min(shap),
    `Max.` = max(shap)
  ) %>%
  ungroup() %>%
  mutate(
    `Rel. Imp.` = `Mean Abs.` / sum(`Mean Abs.`),
    township_code = ccao::town_convert(as.character(township_code)),
    .by = township_code
  ) %>%
  relocate(township_code, .before = everything()) %>%
  relocate(`Rel. Imp.`, .after = feature) %>%
  arrange(township_code, desc(`Mean Abs.`)) %>%
  mutate(
    across(`Mean Abs.`:`Max.`, ~ scales::dollar(.x, accuracy = 0.01)),
    `Rel. Imp.` = scales::percent(`Rel. Imp.`, accuracy = 0.01)
  ) %>%
  rename(Township = township_code, Feature = feature) %>%
  datatable(
    rownames = FALSE,
    filter = "top",
    options = list(
      columnDefs = list(
        list(
          className = "dt-nowrap dt-right",
          targets = c(2:9),
          searchable = FALSE
        ),
        list(
          className = "dt-nowrap",
          targets = 0
        )
      )
    )
  )
```

```{r}

neighborhoods <- ccao::nbhd_shp

chars_data_1year <- chars_data %>%
  filter(meta_year == 2022) %>%
  select(meta_pin, meta_nbhd_code) %>%
  rename(nbhd_code = meta_nbhd_code)

test1 <- shap_df_filtered %>%
  left_join(chars_data_1year, by = c("meta_pin" = "meta_pin")) %>%
  group_by(nbhd_code) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE)

test1 <- test1 %>%
  mutate(nbhd_code = as.character(nbhd_code)) %>%
  left_join(neighborhoods, by = c("nbhd_code" = "town_nbhd")) 

test1$meta_township_code

test1 <- st_as_sf(test1)

pal <- colorNumeric(palette = "viridis", domain = test1$meta_township_code)

leaflet(test1) %>%
  addTiles() %>%
  addPolygons(
    fillColor = ~pal(meta_township_code),
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    highlight = highlightOptions(
      weight = 5,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.7,
      bringToFront = TRUE
    ),
    label = ~as.character(meta_township_code),
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"
    )
  )

```

```{r}

test2 <- test1 %>%
  select(where(is.numeric))


create_palette <- function(column) {
  # Define the range for the positive and negative values separately
  range_pos <- max(column, na.rm = TRUE)
  range_neg <- min(column, na.rm = TRUE)

  # Create a function to map values to colors
  function(value) {
    if (value >= 0) {
      # Scale for positive values
      viridis((value / range_pos), option = "D")
    } else {
      # Scale for negative values (inverted)
      viridis((-value / range_neg), option = "D")
    }
  }
}

# Create a list of color palettes for each numeric column
palettes <- lapply(test2, function(column) {
  if (is.numeric(column)) {
    create_palette(column)
  } else {
    NULL
  }
})

palettes <- palettes[-length(palettes)]


leaflet(test2) %>%
  addTiles() %>%
    addPolygons(
    fillColor = ~pal_yrblt(char_yrblt),
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    group = "Year Built",
    label = ~as.character(char_yrblt),
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"
    )
  ) %>%
    addPolygons(
    fillColor = ~pal_township(meta_township_code),
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    group = "Township Code",
    label = ~as.character(meta_township_code),
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"
    )
  ) %>%
  
  # Layer control
  addLayersControl(
    baseGroups = c("Year Built", "Township Code"),
    options = layersControlOptions(collapsed = TRUE)
  )

```



```{r}

# Create initial leaflet map
leaflet_map <- leaflet(test1) %>%
  addTiles()  # Add default tiles

# Iterate over each numeric column and add it as a layer
numeric_cols <- sapply(test1, is.numeric)
for (col in names(numeric_cols[numeric_cols])) {
  col_sym <- sym(col)
  pal <- colorNumeric(palette = "viridis", domain = test1[[col]])

  # Unquoting the column name within the aesthetic mapping
  leaflet_map <- leaflet_map %>% 
    addPolygons(
      fillColor = ~pal({{ col_sym }}),
      weight = 1,
      opacity = 1,
      color = "white",
      dashArray = "3",
      fillOpacity = 0.7,
      highlightOptions = highlightOptions(
        weight = 5,
        color = "#666",
        dashArray = "",
        fillOpacity = 0.7,
        bringToFront = TRUE
      ),
      label = ~as.character({{ col_sym }}),
      labelOptions = labelOptions(
        style = list("font-weight" = "normal", padding = "3px 8px"),
        textsize = "15px",
        direction = "auto"
      ),
      group = col
    )
}

# Add layer control
leaflet_map <- leaflet_map %>%
  addLayersControl(
    overlayGroups = names(numeric_cols[numeric_cols]),
    options = layersControlOptions(collapsed = FALSE)
  )

leaflet_map


```

```{r}
m <- leaflet(test2) %>% addTiles()

# Function to add a layer for each numeric column
add_column_layer <- function(df, column_name, palette, map) {
  # Assuming each palette is a vector of colors corresponding to the column values
  color_column <- palette[df[[column_name]]]
  map %>% addPolygons(
    fillColor = ~color_column,
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    group = column_name,
    label = ~as.character(df[[column_name]]),
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"
    )
  )
}

m <- leaflet(test2) %>% addTiles()

# Iterate over each numeric column and apply the palette
numeric_columns <- names(test2)[sapply(test2, is.numeric)]


for (i in seq_along(numeric_columns)) {
  column_name <- numeric_columns[i]
  palette <- palettes[[i]]
  m <- add_column_layer(test2, column_name, palette, m)
}

# Add layer control
m <- m %>% addLayersControl(
  baseGroups = numeric_columns,
  options = layersControlOptions(collapsed = TRUE)
)

m # Display the map
```
```{r}
add_column_layer <- function(df, column_name, map) {
  # Create a continuous color palette
  pal <- colorNumeric(palette = "viridis", domain = df[[column_name]], na.color = "transparent")

  # Add polygon layer using this color palette
  map %>% addPolygons(
    fillColor = ~pal(df[[column_name]]),
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    group = column_name,
    label = ~as.character(df[[column_name]]),
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto"
    )
  )
}

```

```{r}
# Initialize Leaflet map
m <- leaflet(test2) %>% addTiles()

# Iterate over each numeric column
numeric_columns <- names(test2)[sapply(test2, is.numeric)]

for (column_name in numeric_columns) {
  m <- add_column_layer(test2, column_name, m)
}

# Add layer control
m <- m %>% addLayersControl(
  baseGroups = numeric_columns,
  options = layersControlOptions(collapsed = TRUE)
)

m # Display the map

```

