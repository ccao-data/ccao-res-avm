---
title: "Challenge Groups"
subtitle: "Run ID: `r params$run_id`"
date: "`r Sys.Date()`"
author: "Cook County Assessor's Office Data Department"
abstract-title: "Run Note"
abstract: '`r arrow::read_parquet(here::here("output/metadata/model_metadata.parquet"))$run_note`'
execute:
  echo: false
  warning: false
format:
  html:
    embed-resources: true
    toc: true
    toc_float: true
    fig-align: center
    fontsize: 12pt
knitr:
  opts_chunk:
    out.width: "100%"
editor: source
params:
  run_id: "2024-03-17-stupefied-maya"
  year: "2024"
---

{{< include ../_setup.qmd >}}

## Definitions

For assessed properties, there are characteristics which make it difficult to predict their market value. These properties are separated out and analyzed in the following report. All outputs are calculated on county-level data. The universe of sold data is from prior year sales.

**Large Lots:** Indicator for a PIN with land square footage larger than 95% of other properties for this year and township.

**Multicard:** Indicates a PIN with more than one building (ADU, coach house, etc.).

**Multifamily:** Indicates a PIN with a class code of 211.

**Top Decile:** Indicator for the top 10% of assessed values by township from the prior year.

## Topline Stats for All Properties

```{r _challenge_groups_topline_stats_all}
full_data_function <- function(col_expr, dataset_name) {
  dataset <- assessment_pin %>%
    filter({{ col_expr }}) %>%
    select(meta_pin, pred_pin_final_fmv_round, sale_ratio_study_price, loc_latitude, loc_longitude, prior_near_tot, meta_township_code)

  return(dataset)
}

large_lots <- full_data_function(flag_land_gte_95_percentile == TRUE, "Large Lots")
multicard <- full_data_function(flag_pin_is_multicard == TRUE, "Multicard")
multifamily <- full_data_function(meta_class == "211", "Multifamily")
top_decile <- full_data_function(flag_prior_near_fmv_top_decile == TRUE, "Top Decile")

datasets_full <- list(
  "Large Lots" = large_lots,
  "Multicard" = multicard,
  "Multifamily" = multifamily,
  "Top Decile" = top_decile
)

full_data_functions <- function(dataset, dataset_name) {
  N <- nrow(dataset)

  median_pred <- median(dataset$pred_pin_final_fmv_round, na.rm = TRUE)
  median_prior <- median(dataset$prior_near_tot, na.rm = TRUE)

  percent_change <- with(dataset, (pred_pin_final_fmv_round - prior_near_tot) / prior_near_tot * 100)
  median_percent_change <- median(percent_change, na.rm = TRUE)

  results_df <- data.frame(
    Dataset = dataset_name,
    Count = N,
    "Median Prior" = scales::dollar(round(median_prior, 2)),
    "Median Predicted" = scales::dollar(round(median_pred, 2)),
    "Median Percent Change" = scales::percent(median_percent_change / 100)
  )

  return(results_df)
}

results_list <- map2(datasets_full, names(datasets_full), ~ full_data_functions(.x, .y))

do.call(bind_rows, results_list) %>%
  rename("Median Prior" = "Median.Prior", "Median Predicted" = "Median.Predicted", "Median Percent Change" = "Median.Percent.Change") %>%
  kable(format = "html", digits = 2, row.names = FALSE, format.args = list(big.mark = ","), align = rep("l", 5)) %>%
  kable_styling()
```
## Ratio Stats for Sold Properties

```{r _challenge_groups_topline_stats_sold}
filter_datasets <- function(datasets) {
  datasets_sold <- lapply(datasets, function(df) {
    df %>% filter(!is.na(sale_ratio_study_price))
  })
  return(datasets_sold)
}

datasets_sold <- filter_datasets(datasets_full)

gte_n <- \(n_sales, min_n, fn, na_type) {
  ifelse(sum(!is.na(n_sales)) >= min_n, fn, na_type)
}

min_n <- 10

rs_fns_list <- list(
  cod_no_sop = \(x, y) gte_n(y, 2, cod(x / y, na.rm = TRUE), NA_real_),
  prd_no_sop = \(x, y) gte_n(y, 2, prd(x, y, na.rm = TRUE), NA_real_),
  prb_no_sop = \(x, y) gte_n(y, 2, prb(x, y, na.rm = TRUE), NA_real_),
  mki_no_sop = \(x, y) gte_n(y, 2, mki(x, y, na.rm = TRUE), NA_real_),
  cod = \(x, y) gte_n(y, min_n, cod(x / y, na.rm = TRUE), NA_real_),
  cod_met = \(x, y) gte_n(y, min_n, cod_met(cod(x / y, na.rm = TRUE)), NA),
  prd = \(x, y) gte_n(y, min_n, prd(x, y, na.rm = TRUE), NA_real_),
  prd_met = \(x, y) gte_n(y, min_n, prd_met(prd(x, y, na.rm = TRUE)), NA),
  prb = \(x, y) gte_n(y, min_n, prb(x, y, na.rm = TRUE), NA_real_),
  prb_met = \(x, y) gte_n(y, min_n, prb_met(prb(x, y, na.rm = TRUE)), NA),
  mki = \(x, y) gte_n(y, min_n, mki(x, y, na.rm = TRUE), NA_real_),
  mki_met = \(x, y) gte_n(y, min_n, mki_met(mki(x, y, na.rm = TRUE)), NA),
  min = \(x) min(x, na.rm = TRUE),
  q25 = \(x) quantile(x, na.rm = TRUE, probs = 0.25),
  median = \(x) median(x, na.rm = TRUE),
  median_sale = \(x, y) median(y, na.rm = TRUE),
  median_ratio = \(x, y) median(x / y, na.rm = TRUE),
  q75 = \(x) quantile(x, na.rm = TRUE, probs = 0.75),
  max = \(x) max(x, na.rm = TRUE)
)

# Some functions require 2 or 1 arguments.
apply_functions <- function(dataset, dataset_name) {
  x <- dataset$pred_pin_final_fmv_round
  y <- dataset$sale_ratio_study_price

  results_rs <- lapply(rs_fns_list, function(f) {
    if (length(formals(f)) == 2) {
      f(x, y)
    } else {
      f(x)
    }
  })

  results_df <- as.data.frame(results_rs)
  results_df$count <- nrow(dataset)
  results_df$median_prior_near_tot <- median(dataset$prior_near_tot, na.rm = TRUE)
  results_df$dataset <- dataset_name

  return(results_df)
}

results <- bind_rows(
  lapply(names(datasets_sold), function(dataset_name) {
    apply_functions(datasets_sold[[dataset_name]], dataset_name)
  })
)

results %>%
  as.data.frame() %>%
  mutate(
    median_change = scales::percent((median - median_prior_near_tot) / median_prior_near_tot),
    min = scales::dollar(round(min, 2)),
    q25 = scales::dollar(round(q25, 2)),
    median = scales::dollar(round(median, 2)),
    `Median Previous Estimate` = scales::dollar(round(median_prior_near_tot, 2)),
    q75 = scales::dollar(round(q75, 2)),
    max = scales::dollar(round(max, 2))
  ) %>%
  select(Dataset = dataset, Count = count, "Median YoY Change" = median_change, "Median Ratio" = median_ratio, COD = cod, PRB = prb, PRD = prd, MKI = mki, Min = min, Q25 = q25, "Median Predicted" = median, "Median Sale" = median_sale, "Median Previous Estimate", Q75 = q75, Max = max) %>%
  kable(format = "html", digits = 2, row.names = FALSE, format.args = list(big.mark = ","), align = rep("l", 15)) %>%
  kable_styling()
```


## Relationship Between Sale and Assessed Values

Sale and assessed values are capped at $2million to increase legibility. 

```{r}
create_plots <- function(datasets) {
  imap(datasets, ~ {
    p <- ggplot(.x, aes(
      x = sale_ratio_study_price / 1000,
      y = pred_pin_final_fmv_round / 1000,
      text = meta_pin # Changed to 'text' for the tooltip
    )) +
      geom_point() +
      geom_abline(intercept = 0, slope = 1, color = "red") +
      scale_x_continuous(
        name = "Actual FMV (Sale Price in $K)",
        limits = c(0, 2000)
      ) +
      scale_y_continuous(
        name = "Estimated FMV (in $K)",
        limits = c(0, 2000)
      ) +
      ggtitle(.y) + # Add the name of the list element as the title
      theme_bw(base_size = 12)

    ggplotly(p, tooltip = "text") # Convert to a plotly object
  })
}
```

```{r, results = 'asis'}
test <- create_plots(datasets_sold[1])
test$'Large Lots'
test <- create_plots(datasets_sold[2])
test$Multicard
test <- create_plots(datasets_sold[3])
test$Multifamily
test <- create_plots(datasets_sold[4])
test$'Top Decile'
```

```{r _challenge_groups_map_function}
process_and_plot <- function(data) {
  town_shp <- ccao::town_shp
  spatial_data <- st_as_sf(data, coords = c("loc_longitude", "loc_latitude"), crs = 4326) %>%
    mutate(Change = pmin(100 * (pred_pin_final_fmv_round / prior_near_tot) - 100, 300))

  town_shp <- st_transform(town_shp, crs = st_crs(spatial_data))

  ggplot() +
    geom_sf(data = spatial_data, aes(color = Change)) +
    geom_sf(data = town_shp, fill = NA, color = "black") +
    theme_minimal() +
    labs(color = "Change (%)") +
    scale_color_gradient2(midpoint = 0, low = "blue", mid = "lightgrey", high = "red", limits = c(-100, 300)) +
    theme(
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_blank()
    )
}

datasets_minus_missing_location <- list(
  "Large Lots" = large_lots,
  "Multicard" = multicard,
  "Multifamily" = multifamily,
  "Top Decile" = top_decile
) %>%
  map(~ filter(.x, !is.na(loc_latitude) & !is.na(loc_longitude)))

plots <- lapply(datasets_minus_missing_location, process_and_plot)
```

## Map of YoY Changes in Assessed Value
Values are capped at an increase of 300% to increase legibility. This includes sold and unsold properties. 

::: {.panel-tabset}

```{r _challenge_groups_map_output, results = 'asis'}
iwalk(plots, ~ {
  cat("## ", .y, "\n\n")

  print(.x)

  cat("\n\n")
})
```
:::
