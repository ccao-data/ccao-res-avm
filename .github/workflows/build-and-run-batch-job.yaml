# Reusable workflow that builds a Docker image, pushes it to the GitHub
# Container Registry, and then optionally uses that container image to run
# an AWS Batch job.
#
# Requirements:
#
#   * A Dockerfile must be defined in the root of the repo whose workflow is
#     calling this one.
#   * A `deploy` environment must be configured in the calling repo. This
#     environment is used to protect the `run` job, which must be approved by
#     a core team member before it will run.
#   * The calling workflow must grant the following permissions to the job
#     that calls this workflow:
#       * contents: read
#       * id-token: write
#       * packages: write
#   * Various required inputs and secrets, documented below, must be passed in
#     by the calling workflow.

name: build-and-run-batch-job

on:
  workflow_call:
    inputs:
      role-duration-seconds:
        description: How long IAM role used to auth with AWS can be valid.
        required: false
        type: string
        default: 3600
      vcpu:
        description: >
          Count of cVPUs to provision for the container. Per AWS requirements,
          must be formatted as a float, e.g. 1.0 for 1 vCPU. The minimum
          is 1 vCPU and values must be specified in increments of 0.25.
        required: false
        type: string
        default: "1.0"
      memory:
        description: Count of megabytes of RAM to provision for the container.
        required: false
        type: string
        default: "4096"
      terraform-working-directory:
        description: Directory where the Terraform configuration is stored.
        required: false
        type: string
        default: .

    secrets:
      AWS_IAM_ROLE_TO_ASSUME_ARN:
        required: true
      AWS_ACCOUNT_ID:
        required: true

env:
  DOCKER_REGISTRY: ghcr.io
  DOCKER_IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image-name: ${{ steps.save-image-name.outputs.image-name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}
          # Tag the following types of images:
          #   * On a branch, tag with the branch name (e.g. `master`)
          #   * On a PR, tag with the PR number (e.g. `pr-12`)
          #   * On a tagged commit, tag with the git tag (e.g. `2023`)
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=ref,event=tag

      - name: Build and push Docker image
        id: build-and-push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Fix incorrect container type sidebar display in GitHub Container
          # Registry
          provenance: false

      - name: Save image name to output
        id: save-image-name
        run: |
          IMAGE_NAME=$(echo "$METADATA" | jq -r '."image.name"')
          echo "image-name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"
        shell: bash
        env:
          METADATA: ${{ steps.build-and-push.outputs.metadata }}

  run:
    # Don't automatically run the model on push, since we prefer to use workflow
    # dispatch for prod runs instead
    if: github.event_name != 'push'
    needs: [build]
    runs-on: ubuntu-latest
    # Require manual approval to run this job
    environment: deploy
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: ./.github/actions/setup-terraform
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_TO_ASSUME_ARN }}
          aws-account-id: ${{ secrets.AWS_ACCOUNT_ID }}
          batch-container-image-name: ${{ needs.build.outputs.image-name }}
          batch-job-definition-vcpu: ${{ inputs.vcpu }}
          batch-job-definition-memory: ${{ inputs.memory }}
          role-duration-seconds: ${{ inputs.role-duration-seconds}}
          working-directory: ${{ inputs.terraform-working-directory }}

      - name: Validate Terraform config
        run: terraform validate
        working-directory: ${{ inputs.terraform-working-directory }}
        shell: bash

      - name: Apply Terraform changes
        run: terraform apply -auto-approve
        working-directory: ${{ inputs.terraform-working-directory }}
        shell: bash

      - name: Submit new Batch job
        id: submit-job
        run: |
          # Use terraform-bin to disable the wrapper script installed by
          # the setup-terraform action, which adds extra context to
          # `terraform output` calls
          BATCH_JOB_NAME="$(terraform-bin output -raw batch_job_name)"
          BATCH_JOB_DEFINITION="$(terraform-bin output -raw batch_job_definition_arn)"
          BATCH_JOB_QUEUE="$(terraform-bin output -raw batch_job_queue_arn)"

          BATCH_JOB_DETAILS=$(\
            aws batch submit-job \
              --job-name "$BATCH_JOB_NAME" \
              --job-definition "$BATCH_JOB_DEFINITION" \
              --job-queue "$BATCH_JOB_QUEUE" \
          )
          BATCH_JOB_ID=$(echo $BATCH_JOB_DETAILS | jq -r ".jobId")
          echo "batch-job-id=$BATCH_JOB_ID" >> "$GITHUB_OUTPUT"
        shell: bash
        working-directory: ${{ inputs.terraform-working-directory }}

      - name: Wait for Batch job to start and print link to AWS logs
        run: ./.github/scripts/poll_batch_job_status.sh "$BATCH_JOB_ID" startup
        shell: bash
        env:
          BATCH_JOB_ID: ${{ steps.submit-job.outputs.batch-job-id }}

      - name: Wait for Batch job to complete
        run: ./.github/scripts/poll_batch_job_status.sh "$BATCH_JOB_ID"
        shell: bash
        env:
          BATCH_JOB_ID: ${{ steps.submit-job.outputs.batch-job-id }}
