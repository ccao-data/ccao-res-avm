{{< include ../shared/setup_shared.qmd >}}

# SHAP

The primary metric that the CCAO Data team uses to assess the importance of a feature is its SHAP value. SHAP values provide the amount of value each feature contributes to a parcel's predicted value. The SHAP value is calculated for each observation in the dataset, and the median SHAP value for a feature is used to determine the relative influence of that feature. The higher the median SHAP value, the more influential the feature is in the model.

## Tables
::: {.panel-tabset}

```{r, _shaps_categorical_count}
shap_predictors <- unlist(metadata_new$model_predictor_all_name)
```

```{r _shaps_categorical_processing}
# Combine data
shap_df_filtered_long <- shap_new %>%
  inner_join(
    assessment_data_new %>%
      select(meta_pin, meta_card_num, meta_township_code, meta_nbhd_code) %>%
      rename(township_code = meta_township_code, neighborhood_code = meta_nbhd_code),
    by = c("meta_pin", "meta_card_num")
  ) %>%
  select(township_code, all_of(shap_predictors)) %>%
  pivot_longer(
    cols = all_of(shap_predictors),
    names_to = "feature",
    values_to = "shap"
  )
```

### SHAP Median Absolute Value
The following table produces the median absolute SHAP value by township, and creates a grouped table. In total, there are `r length(shap_predictors)` indicators in the model. Thus, if the median SHAP is ranked 1, it is the most important feature, while if it is ranked `r length(shap_predictors)`, it is the least important feature in a township. The median value (without absolute) is also included to better contextualize the impact.

```{r _shaps_categorical_full_importance}
shap_df_filtered_long %>%
  group_by(feature) %>%
  mutate(
    median_abs_shap = round(median(abs(shap), na.rm = TRUE), 2),
    median_shap = round(median(shap, na.rm = TRUE), 2)
  ) %>%
  ungroup() %>%
  distinct(feature, .keep_all = TRUE) %>%
  arrange(desc(median_abs_shap)) %>%
  mutate(
    rank_absolute = row_number(),
    `Median Absolute Shap` = scales::dollar(median_abs_shap),
    `Median SHAP` = scales::dollar(median_shap)
  ) %>%
  inner_join(ccao::town_dict, by = c("township_code" = "township_code")) %>%
  ccao::vars_rename(
    names_from = "model",
    names_to = "pretty",
    output_type = "inplace",
    dictionary = ccao::vars_dict
  ) %>%
  clean_column_values("feature") %>%
  select(
    Feature = feature,
    "Median Absolute Shap",
    "Median SHAP",
    "Rank Absolute" = rank_absolute
  ) %>%
  datatable(
    options = list(
      scrollY = "300px",
      scrollX = TRUE,
      paging = FALSE,
      searching = TRUE
    ),
    rownames = FALSE
  )
```

### SHAP Median Absolute Value by Township

This is the same table, except ranked by township. To identify the rank of an indicator within a township, simply search for that township in the search bar.
```{r _shaps_categorical_township_importance, echo=FALSE,warning=FALSE,message=FALSE,error=FALSE, results='asis',fig.keep='all'}
shap_df_filtered_long %>%
  group_by(township_code, feature) %>%
  mutate(
    median_abs_shap = round(median(abs(shap), na.rm = TRUE), 2),
    median_shap = round(median(shap, na.rm = TRUE), 2)
  ) %>%
  ungroup() %>%
  distinct(township_code, feature, .keep_all = TRUE) %>%
  group_by(township_code) %>%
  arrange(desc(median_abs_shap), .by_group = TRUE) %>%
  mutate(
    township_rank_absolute = row_number(),
    `Median Absolute Shap` = scales::dollar(median_abs_shap),
    `Median SHAP` = scales::dollar(median_shap)
  ) %>%
  ungroup() %>%
  inner_join(ccao::town_dict, by = c("township_code" = "township_code")) %>%
  ccao::vars_rename(
    names_from = "model",
    names_to = "pretty",
    output_type = "inplace",
    dictionary = ccao::vars_dict
  ) %>%
  clean_column_values("feature") %>%
  select(
    Township = township_name,
    `Township Code` = township_code,
    Feature = feature,
    `Median Absolute Shap`,
    `Median SHAP`,
    `Township Rank Absolute` = township_rank_absolute
  ) %>%
  datatable(
    options = list(
      scrollY = "300px",
      scrollX = TRUE,
      paging = FALSE,
      searching = TRUE
    ),
    rownames = FALSE
  )
```

:::

## SHAP Charts
::: {.panel-tabset}

### Scatterplot

```{r _shaps_categorical_scatterplot, echo=FALSE,warning=FALSE,message=FALSE,error=FALSE, results='asis',fig.keep='all'}
shapviz::shapviz(
  object = shap_new %>%
    select(all_of(shap_predictors)) %>%
    as.matrix(),
  X = assessment_card_new %>%
    select(all_of(shap_predictors)),
  baseline = shap_new$pred_card_shap_baseline_fmv[1]
) %>%
  shapviz::sv_dependence(
    v = target_feature_value
  )
```


### Violin Plot

Y limit is set to the 2.5th and 97.5th percentiles of the SHAP values for readibility.

```{r _shaps_categorical_violin_plot, results='asis', fig.keep='all'}
# Calculate the number of digits
num_digits <- card_individual %>%
  pull({{ target_feature_shap }}) %>%
  max(na.rm = TRUE) %>%
  floor() %>%
  as.character() %>%
  str_length()

quantiles <- card_individual %>%
  pull({{ target_feature_shap }}) %>%
  quantile(c(0.025, 0.975), na.rm = TRUE)

# Calculate the number of unique values
num_unique_values <- card_individual %>%
  pull(!!sym(target_feature_value)) %>%
  n_distinct()

# Determine binning logic
card_individual <- card_individual %>%
  mutate(
    bin = if (num_unique_values <= 9) {
      as.character(!!sym(target_feature_value))
    } else {
      cut_interval(!!sym(target_feature_value), n = 5, dig.lab = 2)
    }
  )

card_individual %>%
  ggplot(aes(x = bin, y = !!sym(target_feature_shap))) +
  geom_violin(fill = "#69b3a2", alpha = 0.7) +
  theme_minimal() +
  xlab("Feature Value") +
  ylab("SHAP Value") +
  coord_cartesian(ylim = quantiles) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    plot.title = element_text(hjust = 0.5)
  ) +
  ggtitle("Violin Plot of SHAP Values for Feature Ranges")
```
:::

