---
title: "Testing the Impact of Adding a New Variable on the Model"
format: html
---
```{r, include = FALSE}
library(sf)
library(dplyr)
library(ggplot2)
library(noctua)
library(arrow)
library(kableExtra)
library(spdep)
library(leaflet)
library(purrr)


con <- dbConnect(noctua::athena())
noctua::noctua_options(cache = 10)

variable <- 'prox_nearest_new_construction_dist_ft'
variable_shap <- 'prox_nearest_new_construction_dist_ft_shap'

input_data <- read_parquet("input/assessment_data.parquet") %>%
  select(meta_pin, meta_township_name, meta_nbhd_code, meta_card_num, variable, loc_census_acs5_tract_geoid, meta_pin10, loc_longitude, loc_latitude)

working_data <- read_parquet("output/shap/model_shap.parquet") %>%
  select(meta_pin, !!sym(variable), meta_card_num) %>%
  rename(!!variable_shap := !!sym(variable)) %>%
  mutate(pin10 = substr(meta_pin, 1, 10)) %>%
  inner_join(input_data, by = c("meta_pin", "meta_card_num")) %>%
  group_by(meta_township_name) %>%
  mutate(
    !!paste0(variable_shap, "_township_mean") := mean(abs(!!sym(variable_shap)), na.rm = TRUE),
    !!paste0(variable_shap, "_township_sd") := sd(abs(!!sym(variable_shap)), na.rm = TRUE),
    !!paste0(variable_shap, "_township_90th") := quantile(abs(!!sym(variable_shap)), 0.9, na.rm = TRUE),
    !!paste0(variable, "_township_mean") := mean(!!sym(variable), na.rm = TRUE),
    !!paste0(variable, "_township_sd") := sd(!!sym(variable), na.rm = TRUE),
    !!paste0(variable, "_township_90th") := quantile(!!sym(variable), 0.9, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  group_by(meta_nbhd_code) %>%
  mutate(
    !!paste0(variable_shap, "_neighborhood_mean") := mean(abs(!!sym(variable_shap)), na.rm = TRUE),
    !!paste0(variable_shap, "_neighborhood_sd") := sd(abs(!!sym(variable_shap)), na.rm = TRUE),
    !!paste0(variable_shap, "_neighborhood_90th") := quantile(abs(!!sym(variable_shap)), 0.9, na.rm = TRUE),
    !!paste0(variable, "_neighborhood_mean") := mean(!!sym(variable), na.rm = TRUE),
    !!paste0(variable, "_neighborhood_sd") := sd(!!sym(variable), na.rm = TRUE),
    !!paste0(variable, "_neighborhood_90th") := quantile(!!sym(variable), 0.9, na.rm = TRUE)
  ) %>%
  ungroup()


nbhd <- ccao::nbhd_shp

spatial_data <- working_data %>%
  distinct(meta_nbhd_code, .keep_all = TRUE) %>%
  inner_join(nbhd, by = c("meta_nbhd_code" = "town_nbhd")) %>%
  st_as_sf()

```

### Neighborhood level mean of distance to new construction

```{r, echo = FALSE}
spatial_data %>%
  ggplot() +
  geom_sf(aes(fill = !!sym(paste0(variable, "_neighborhood_mean")))) +
  scale_fill_viridis_c(option = "viridis", name = "Value") +
  theme_void() +
  coord_sf(xlim = c(-88.4, -87.52398), ylim = c(41.5, 42.2))

```
## Township level mean of distance to new construction

```{r, echo = FALSE}
spatial_data %>%
  ggplot() +
  geom_sf(aes(fill = !!sym(paste0(variable, "_township_mean"))), color = NA) +
  scale_fill_viridis_c(option = "viridis", name = "Value") +
  theme_void() +
  coord_sf(xlim = c(-88.4, -87.52398), ylim = c(41.5, 42.2))
```



## Leaflet of Neighborhoods with two lowest mean values

```{r, echo = FALSE}
working_data <- working_data %>%
  group_by(meta_nbhd_code) %>%
  mutate(!!paste0(variable, "_mean") := mean(!!sym(variable), na.rm = TRUE)) %>%
  ungroup()

# Create the new variable name
new_variable <- paste0(variable, "_mean")

selected_neighborhoods <- working_data %>%
  distinct(meta_nbhd_code, .keep_all = TRUE) %>%
  arrange(!!sym(paste0(variable, "_neighborhood_mean"))) %>%
  slice(c(1:2, (n() - 1):n())) %>%
  pull(meta_nbhd_code)

# Filter the data to include only the selected neighborhoods
selected_data <- input_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods)

# Separate high and low value neighborhoods
high_value_data <- selected_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods[3:4])

low_value_data <- selected_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods[1:2])

# Define color palettes for each subset
pal_high <- colorNumeric(
  palette = "viridis",
  domain = high_value_data[[variable]]
)

pal_low <- colorNumeric(
  palette = "viridis",
  domain = low_value_data[[variable]]
)

# Assuming high_value_data is already prepared and contains the necessary columns
map_high <- leaflet(high_value_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~loc_longitude,
    lat = ~loc_latitude,
    radius = 5,
    color = ~pal_high(get(variable)),
    popup = ~ paste(
      paste0(variable, ": $"), formatC(get(variable), digits = 0), 
      "<br>pin:", meta_pin
    )
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_high,
    values = ~get(variable),
    title = "Legend (High Value)"
  )

# To display the map
map_high

```


## Leaflet of Neighborhoods with two lowest mean values
```{r, echo = FALSE}
# Create Leaflet map for low value neighborhoods
map_low <- leaflet(low_value_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~loc_longitude,
    lat = ~loc_latitude,
    radius = 5,
    color = ~pal_low(get(variable)),
    label = ~paste0(variable, ": ", get(variable))
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_low,
    values = ~get(variable),
    title = "Legend (Low Value)"
  )

# Print maps

map_low


```

## Neighborhoods with two highest standard deviations

```{r, echo = FALSE}
working_data <- working_data %>%
  group_by(meta_nbhd_code) %>%
  mutate(
    mean_value = mean(!!sym(variable), na.rm = TRUE),
    sd_value = sd(!!sym(variable), na.rm = TRUE)
  ) %>%
  ungroup()

# Select neighborhoods with the two highest and two lowest standard deviations
selected_neighborhoods <- working_data %>%
  distinct(meta_nbhd_code, .keep_all = TRUE) %>%
  arrange(sd_value) %>%
  slice(c(1:2, (n() - 1):n())) %>%
  pull(meta_nbhd_code)

# Filter the data to include only the selected neighborhoods
selected_data <- input_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods)

# Separate high and low standard deviation neighborhoods
high_sd_data <- selected_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods[(length(selected_neighborhoods) - 1):length(selected_neighborhoods)])

low_sd_data <- selected_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods[1:2])

# Define color palettes for each subset
pal_high_sd <- colorNumeric(
  palette = "viridis",
  domain = high_sd_data[[variable]]
)

pal_low_sd <- colorNumeric(
  palette = "viridis",
  domain = low_sd_data[[variable]]
)

# Create Leaflet map for high standard deviation neighborhoods
map_high_sd <- leaflet(high_sd_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~loc_longitude,  # Replace 'loc_longitude' with your actual longitude column name
    lat = ~loc_latitude,   # Replace 'loc_latitude' with your actual latitude column name
    radius = 5,
    color = ~pal_high_sd(get(variable)),  # Use get(variable) to reference the column dynamically
    label = ~paste0(variable, ": ", get(variable))
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_high_sd,
    values = ~get(variable),
    title = "Legend (High SD Neighborhoods)"
  )

map_high_sd
```

## Neighborhoods with two lowest standard deviations

```{r, echo = FALSE}
# Create Leaflet map for low standard deviation neighborhoods
map_low_sd <- leaflet(low_sd_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~loc_longitude,  # Replace 'loc_longitude' with your actual longitude column name
    lat = ~loc_latitude,   # Replace 'loc_latitude' with your actual latitude column name
    radius = 5,
    color = ~pal_low_sd(get(variable)),  # Use get(variable) to reference the column dynamically
    label = ~paste0(variable, ": ", get(variable))
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_low_sd,
    values = ~get(variable),
    title = "Legend (Low SD Neighborhoods)"
  )

# Print maps
map_low_sd
```

### Median Absolute SHAP Values by Neighborhood
```{r, echo = FALSE}
ggplot(data = spatial_data) +
  geom_sf(aes(fill = !!sym(paste0(variable_shap, "_neighborhood_mean")))) +
  scale_fill_viridis_c(option = "viridis") +
  theme_void() +
  labs(
    fill = "Added $ Value"
  )
```



### Median Absolute SHAP Values by Township

```{r, echo = FALSE}
ggplot(data = spatial_data) +
  geom_sf(aes(fill = !!sym(paste0(variable_shap, "_township_mean"))), color = NA) +
  scale_fill_viridis_c(option = "viridis") +
  theme_void() +
  labs(
    fill = "Added $ Value"
  )
```


## Median SHAP Absolute Values of the 90th percentile


```{r, echo = FALSE}

ggplot(data = spatial_data) +
  geom_sf(aes(fill = !!sym(paste0(variable_shap, "_neighborhood_90th")))) +
  scale_fill_viridis_c(option = "viridis") +
  theme_void() +
  labs(
    fill = "Added $ Value"
  )
```
## High Standard Deviation SHAP Values

```{r, echo = FALSE}
working_data <- working_data %>%
  group_by(meta_nbhd_code) %>%
  mutate(
    mean_value = mean(!!sym(variable_shap), na.rm = TRUE),
    sd_value = sd(!!sym(variable_shap), na.rm = TRUE)
  ) %>%
  ungroup()

# Select neighborhoods with the two highest and two lowest standard deviations
selected_neighborhoods <- working_data %>%
  distinct(meta_nbhd_code, .keep_all = TRUE) %>%
  arrange(sd_value) %>%
  slice(c(1:2, (n() - 1):n())) %>%
  pull(meta_nbhd_code)

# Filter the data to include only the selected neighborhoods
selected_data <- working_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods)

# Separate high and low standard deviation neighborhoods
high_sd_data <- selected_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods[(length(selected_neighborhoods) - 1):length(selected_neighborhoods)])

low_sd_data <- selected_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods[1:2])

# Define color palettes for each subset
pal_high_sd <- colorNumeric(
  palette = "viridis",
  domain = high_sd_data[[variable_shap]]
)

pal_low_sd <- colorNumeric(
  palette = "viridis",
  domain = low_sd_data[[variable_shap]]
)

# Create Leaflet map for high standard deviation neighborhoods
map_high_sd <- leaflet(high_sd_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~loc_longitude, 
    lat = ~loc_latitude,
    radius = 5,
    color = ~pal_high_sd(get(variable_shap)),  # Use get(variable) to reference the column dynamically
    label = ~paste0(variable_shap, ": ", get(variable_shap))
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_high_sd,
    values = ~get(variable_shap),
    title = "Legend (High SD Neighborhoods)"
  )

map_high_sd
```
## Low standard deviation SHAP Values

```{r, echo =FALSE}
map_low_sd <- leaflet(low_sd_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~loc_longitude,  # Replace 'loc_longitude' with your actual longitude column name
    lat = ~loc_latitude,   # Replace 'loc_latitude' with your actual latitude column name
    radius = 5,
    color = ~pal_low_sd(get(variable_shap)),  # Use get(variable) to reference the column dynamically
    label = ~paste0(variable_shap, ": ", get(variable_shap))
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_low_sd,
    values = ~get(variable_shap),
    title = "Legend (High SD Neighborhoods)"
  )

map_low_sd
```

## High absolute value mean of standard deviation
```{r, echo = FALSE}
working_data <- working_data %>%
  group_by(meta_nbhd_code) %>%
  mutate(
    mean_value = mean(abs(!!sym(variable_shap)), na.rm = TRUE),
    mean_value = mean(abs(!!sym(variable_shap)), na.rm = TRUE)
  ) %>%
  ungroup()

# Select neighborhoods with the two highest and two lowest standard deviations
selected_neighborhoods <- working_data %>%
  distinct(meta_nbhd_code, .keep_all = TRUE) %>%
  arrange(mean_value) %>%
  slice(c(1:2, (n() - 1):n())) %>%
  pull(meta_nbhd_code)

# Filter the data to include only the selected neighborhoods
selected_data <- working_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods)

# Separate high and low standard deviation neighborhoods
high_mean_data <- selected_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods[(length(selected_neighborhoods) - 1):length(selected_neighborhoods)])

low_mean_data <- selected_data %>%
  filter(meta_nbhd_code %in% selected_neighborhoods[1:2])

# Define color palettes for each subset
pal_high_mean <- colorNumeric(
  palette = "viridis",
  domain = high_mean_data[[variable_shap]]
)

pal_low_mean <- colorNumeric(
  palette = "viridis",
  domain = low_mean_data[[variable_shap]]
)

# Create Leaflet map for high standard deviation neighborhoods
map_high_mean <- leaflet(high_mean_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~loc_longitude, 
    lat = ~loc_latitude,
    radius = 5,
    color = ~pal_high_mean(get(variable_shap)),  # Use get(variable) to reference the column dynamically
    label = ~paste0(variable_shap, ": ", get(variable_shap))
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_high_mean,
    values = ~get(variable_shap),
    title = "Legend (High mean Neighborhoods)"
  )

map_high_mean
```
### Low absolute mean shap values
```{r, echo = FALSE}
map_low_mean <- leaflet(low_mean_data) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~loc_longitude,  # Replace 'loc_longitude' with your actual longitude column name
    lat = ~loc_latitude,   # Replace 'loc_latitude' with your actual latitude column name
    radius = 5,
    color = ~pal_low_mean(get(variable_shap)),  # Use get(variable) to reference the column dynamically
    label = ~paste0(variable_shap, ": ", get(variable_shap))
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_low_mean,
    values = ~get(variable_shap),
    title = "Legend (High mean Neighborhoods)"
  )

map_low_mean
```


## Correlation between SHAP and the metric

```{r, echo = FALSE}
correlation_value <- cor(pull(working_data, variable), pull(working_data, variable_shap), use = "complete.obs")

correlation_value
```
## Does the inclusion of the new feature affect statistics?

```{r, echo = FALSE, warning = FALSE, results='asis'}
# Load old model data
old_model <- dbGetQuery(
  conn = con,
  "SELECT * FROM model.performance WHERE run_id = '2024-03-17-stupefied-maya'"
) %>%
  filter(is.na(class)) %>%
  filter(stage == "assessment")

# Load new model data
new_model <- read_parquet("output/performance/model_performance_assessment.parquet") %>%
  filter(is.na(class)) %>%
  rename_with(~ paste0(., "_new"), -c(geography_id, geography_type))

# Join and select necessary columns
combined_data <- inner_join(old_model, new_model, by = c("geography_id", "geography_type")) %>%
  select(geography_id, geography_type, mki, mki_new, cod, cod_new, prb, prb_new, prd, prd_new, r_squared, r_squared_new) %>%
  mutate(across(c(mki, mki_new, cod, cod_new, prb, prb_new, prd, prd_new, r_squared, r_squared_new), round, 2))

# Create tables for each geography type

geography_tables <- combined_data %>%
  group_by(geography_type) %>%
  group_split() %>%
  map(~ {
    .x %>%
      select(-geography_type) %>%
      kable(
        format = "html",
        col.names = c("Geography ID", "MKI", "MKI New", "COD", "COD New", "PRB", "PRB New", "PRD", "PRD New", "R Squared", "R Squared New"),
        caption = paste("Intra Model Test Results for Geography Type:", unique(.x$geography_type))
      ) %>%
      kable_styling(position = "center") %>%
      scroll_box(height = "400px", width = "100%")
  })


```

### Stats comprisons
::: {.panel-tabset}

### Table1

```{r _comp_neighborhood_level_means, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[1]]
```
### Table2
```{r, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[2]]
```
### Table3
```{r, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[3]]
```
### Table4
```{r, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[4]]
```
### Table5
```{r, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[5]]
```
### Table6
```{r, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[6]]
```
### Table7
```{r, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[7]]
```
### Table8
```{r, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[8]]
```
### Table9
```{r, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[9]]
```
### Table
```{r, results='asis', echo=FALSE}
# Render the first table inline
geography_tables[[10]]
```
:::
